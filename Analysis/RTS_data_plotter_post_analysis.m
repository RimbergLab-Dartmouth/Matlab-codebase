m_power = 4;
m_flux = 1;
m_gate = 1;
m_detuning = 1;
m_repetition = 1;
plotting.plot_visible = 1;
plotting.save_png = 0;
plotting.save_fig = 0;
plotting.file_to_load_input_params_from = ['\\dartfs-hpc\rc\lab\R\RimbergA\cCPT_NR_project\Bhar_measurements\2022_December_Jules_sample\switching_rate_finder\data_230107\data\' ...
        'switching_finder_comprehensive_data.mat'];
load(post_run_params.file_to_load_input_params_from, 'input_params', 'post_run_analysis')
detuning_point = input_params.detunings(m_power, m_flux, m_gate, m_detuning, m_repetition);

%% retrieve plotting info for specific point from saved dataset
temp.hist_RTS_bins = post_run_analysis.hist_RTS_bins(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.hist_count_data = post_run_analysis.hist_count_data(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.gaussian_1_theory_values = post_run_analysis.gaussian_1_theory_values(m_power, m_flux, m_gate, m_detuning, m_repetition,:);
temp.gaussian_2_theory_values = post_run_analysis.gaussian_2_theory_values(m_power, m_flux, m_gate, m_detuning, m_repetition,:);
temp.gaussian_1_mean = post_run_analysis.gaussian_1_mean(m_power, m_flux, m_gate, m_detuning, m_repetition);
temp.gaussian_2_mean = post_run_analysis.gaussian_2_mean(m_power, m_flux, m_gate, m_detuning, m_repetition);
temp.sigma_double_gaussian = post_run_analysis.sigma_double_gaussian(m_power, m_flux, m_gate, m_detuning, m_repetition);
temp.single_gaussian_fit_params = post_run_analysis.single_gaussian_fit_params(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.clean_time_data = post_run_analysis.RTS.clean_time_data(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
raw_data.phase_extracted = post_run_analysis.RTS.raw_phase(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
raw_data.time_corrected = post_run_analysis.RTS.time(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.raw_data_out = post_run_analysis.RTS.moving_mean_average_phase(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.clean_RTS_data = post_run_analysis.RTS.clean_RTS_phase(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.double_gaussian_existence = post_run_analysis.sign_of_bistability(m_power, m_flux, m_gate, m_detuning, m_repetition);
temp.freqs = post_run_analysis.RTS_PSD.freqs(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.psd_dBm = post_run_analysis.RTS_PSD.psd_dBm(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.lifetime_state_1_final_iteration = post_run_analysis.lifetime_state_1_final_iteration(m_power, m_flux, m_gate, m_detuning, m_repetition);
temp.lifetime_state_2_final_iteration = post_run_analysis.lifetime_state_2_final_iteration(m_power, m_flux, m_gate, m_detuning, m_repetition);
temp.theory_lorentzian = 4*(abs(temp.gaussian_1_mean - temp.gaussian_2_mean))^2 ./ ((temp.lifetime_state_1_final_iteration + temp.lifetime_state_2_final_iteration) .* ...
                ((1/temp.lifetime_state_1_final_iteration + 1/ temp.lifetime_state_2_final_iteration)^2 + (2*pi*temp.freqs).^2));
temp.amp_diff_lorentz_fit = post_run_analysis.RTS_PSD_fits.lorentzian_fit_amp_diff(m_power, m_flux, m_gate, m_detuning, m_repetition);
temp.lifetime_state_1_lorentz_fit = post_run_analysis.RTS_PSD_fits.lorentzian_fit_lifetime_state_1(m_power, m_flux, m_gate, m_detuning, m_repetition);
temp.lifetime_state_2_lorentz_fit = post_run_analysis.RTS_PSD_fits.lorentzian_fit_lifetime_state_2(m_power, m_flux, m_gate, m_detuning, m_repetition);
temp.theory_lorentzian_fit = 4*temp.amp_diff_lorentz_fit^2 ./ ((temp.lifetime_state_1_lorentz_fit + temp.lifetime_state_2_lorentz_fit) .* ...
        ((1/temp.lifetime_state_1_lorentz_fit + 1/ temp.lifetime_state_2_lorentz_fit)^2 + (2*pi*freqs).^2));    
temp.analysis.current_run_bistability_existence = post_run_analysis.analysis.current_run_bistability_existence (m_power, m_flux, m_gate, m_repetition);    
temp.switch_time_bin_centers_1 = post_run_analysis.Poissonian.switch_time_bin_centers_1(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.switch_time_bin_centers_2 = post_run_analysis.Poissonian.switch_time_bin_centers_2(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.hist_count_1 = post_run_analysis.Poissonian.hist_count_1(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.hist_count_2 = post_run_analysis.Poissonian.hist_count_2(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.poisson_theory_1 = post_run_analysis.Poissonian.poisson_theory_1(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
temp.poisson_theory_2 = post_run_analysis.Poissonian.poisson_theory_2(m_power, m_flux, m_gate, m_detuning, m_repetition, :);
%% Plotting Gaussian fits to RTS data
if plotting.plot_visible == 1
    RTS_Gaussians = figure('units', 'normalized', 'outerposition', [0 0 1 1]);
elseif plotting.plot_visible == 0    
    RTS_Gaussians = figure('units', 'normalized', 'outerposition', [0 0 1 1],'visible','off');
end
bar(temp.hist_RTS_bins, temp.hist_count_data, 'DisplayName', 'raw data')
hold on
if temp.double_gaussian_existence 
    plot(temp.hist_RTS_bins, temp.gaussian_1_theory_values,'r', 'linewidth', 3,'DisplayName', 'Gaussian 1 theory')
    plot(temp.hist_RTS_bins, temp.gaussian_2_theory_values,'k', 'linewidth', 3, 'DisplayName', 'Gaussian 2 theory')
end
plot(temp.hist_RTS_bins, temp.single_gaussian_theory_values,'g', 'linewidth', 3,'DisplayName', 'Single Gaussian theory')
xlabel('Phase ($^\circ$)', 'interpreter', 'latex')
ylabel('Count', 'interpreter', 'latex')
title(['RTS Gaussians for P$_{\mathrm{in}}$ = ' num2str(input_params.input_power_value_list(m_power)) 'dBm' 13 10 ...
'$n_g = $' num2str(input_params.ng_1_value_list(m_gate)) ', $\Phi_{\mathrm{ext}}$ = ' ...
num2str(input_params.flux_1_value_list(m_flux)) '$\Phi_0$' 13 10 ...
'$\Delta$ = ' num2str(detuning_point) 'MHz, ' ...
'Repetition number= ' num2str(m_repetition) 13 10 ...
'center gaussian 1 = ' num2str(round(temp.gaussian_1_mean, 2)) '$^\circ$, ' ...
'center gaussian 2 = ' num2str(round(temp.gaussian_2_mean, 2)) '$^\circ$, ' ...
'double gaussian $\sigma$ = ' num2str(round(temp.sigma_double_gaussian, 2)) '$^\circ$' 13 10 ...
'single gaussian center = ' num2str(round(temp.single_gaussian_fit_params(2), 2)) '$^\circ$', ...
'single gaussian $\sigma$ = ' num2str(round(temp.single_gaussian_fit_params(3), 2)) '$^\circ$'], 'interpreter', 'latex')
legend show

if plotting.save_png  == 1
    save_file_name = [post_run_params.rts_fig_directory num2str(m_power) '_' ...
        num2str(m_bias_point) '_' num2str(m_detuning) ...
        '_' num2str(m_repetition) ...
        '_' num2str(input_params.input_power_value_list(m_power)) 'dBm_' ...
        '_ng_' num2str(input_params.ng_1_value_list(m_gate)) '_flux_' ...
        num2str(input_params.flux_1_value_list(m_flux)*1000) 'm_detuning_' ...
        num2str(detuning_point) 'MHz_RTS_gaussian.png'];
    saveas(RTS_Gaussians, save_file_name)
    if plotting.save_fig 
        save_file_name = [post_run_params.rts_fig_directory '/fig_files/' num2str(m_power) '_' ...
        num2str(m_bias_point) '_' num2str(m_detuning) ...
        '_' num2str(m_repetition) ...
        '_' num2str(input_params.input_power_value_list(m_power)) 'dBm_' ...
        '_ng_' num2str(input_params.ng_1_value_list(m_gate)) '_flux_' ...
        num2str(input_params.flux_1_value_list(m_flux)*1000) 'm_detuning_' ...
        num2str(detuning_point) 'MHz_RTS_gaussian.fig'];
        saveas(RTS_Gaussians, save_file_name)
    end
end
clear RTS_Gaussians ...
  save_file_name     
%% Plotting a section of the RTS
if plotting.plot_visible == 1
    RTS_figure = figure('units', 'normalized', 'outerposition', [0 0 1 1]);
elseif plotting.plot_visible == 0    
    RTS_figure = figure('units', 'normalized', 'outerposition', [0 0 1 1],'visible','off');
end
plot(temp.clean_time_data(1,start_point : start_point + post_run_params.analysis.plotting_number_for_RTS)*1e6, ...
raw_data.phase_extracted(1,start_point : start_point + post_run_params.analysis.plotting_number_for_RTS), 'r', 'DisplayName', 'raw data')
hold on
plot(raw_data.time_corrected(1,start_point : start_point + post_run_params.analysis.plotting_number_for_RTS)*1e6, ...
squeeze(temp.raw_data_out(1, start_point : start_point + post_run_params.analysis.plotting_number_for_RTS)), ...
'b', 'DisplayName', 'moving averaged data')
plot(raw_data.time_corrected(1, start_point : start_point + post_run_params.analysis.plotting_number_for_RTS)*1e6, ...
squeeze(temp.clean_RTS_data(1, start_point : start_point + post_run_params.analysis.plotting_number_for_RTS)), ...
'k', 'linewidth', 3, 'DisplayName', 'cleaned data')
xlabel('Time ($\mu$s)', 'interpreter', 'latex')
ylabel('Phase($S_{21}) (^\circ$)', 'interpreter', 'latex')
title(['RTS for P$_{\mathrm{in}}$ = ' num2str(input_params.input_power_value_list(m_power)) 'dBm' 13 10 ...
'$n_g = $' num2str(input_params.ng_1_value_list(m_gate)) ', $\Phi_{\mathrm{ext}}$ = ' ...
num2str(input_params.flux_1_value_list(m_flux)) '$\Phi_0$' 13 10 ...
        '$\Delta$ = ' num2str(detuning_point) 'MHz, ' ...
'Repetition number= ' num2str(m_repetition)], 'interpreter', 'latex')
legend show

if plotting.save_png  == 1
    save_file_name = [post_run_params.rts_fig_directory num2str(m_power) '_' ...
        num2str(m_bias_point) '_' num2str(m_detuning) ...
        '_' num2str(m_repetition) ...
        '_' num2str(input_params.input_power_value_list(m_power)) 'dBm_' ...
        '_ng_' num2str(input_params.ng_1_value_list(m_gate)) '_flux_' ...
        num2str(input_params.flux_1_value_list(m_flux)*1000) 'm_detuning_' ...
        num2str(detuning_point) 'MHz_RTS_signal.png'];
    saveas(RTS_figure, save_file_name)
    if plotting.save_fig  == 1
        save_file_name = [post_run_params.rts_fig_directory '/fig_files/' num2str(m_power) '_' ...
        num2str(m_bias_point) '_' num2str(m_detuning) ...
        '_' num2str(m_repetition) ...
        '_' num2str(input_params.input_power_value_list(m_power)) 'dBm_' ...
        '_ng_' num2str(input_params.ng_1_value_list(m_gate)) '_flux_' ...
        num2str(input_params.flux_1_value_list(m_flux)*1000) 'm_detuning_' ...
        num2str(detuning_point) 'MHz_RTS_signal_sample.fig'];
        saveas(RTS_figure, save_file_name)
    end
end

clear RTS_figure ...
  save_file_name ...
  start_point
%% Plotting PSD 
if temp.double_gaussian_existence == 1
    if plotting.plot_visible == 1
        RTS_PSD_figure = figure('units', 'normalized', 'outerposition', [0 0 1 1]);
    elseif plotting.plot_visible == 0 
        RTS_PSD_figure = figure('units', 'normalized', 'outerposition', [0 0 1 1],'visible','off');
    end

    semilogx(temp.freqs/1e3, temp.psd_dBm, 'r', 'DisplayName', 'PSD data')
    hold on
    semilogx(temp.freqs/1e3, convert_fraction_to_dB(temp.theory_lorentzian), 'b', 'DisplayName', 'Theoretical Lorentzian')
    semilogx(temp.freqs/1e3, convert_fraction_to_dB(temp.theory_lorentzian_fit), 'k', 'DisplayName', 'Fit Lorentzian')
    xlabel('Freq (kHz)', 'interpreter', 'latex')
    ylabel('PSD (dB $^\circ$))', 'interpreter', 'latex')

    title(['RTS PSD for P$_{\mathrm{in}}$ = ' num2str(input_params.input_power_value_list(m_power)) 'dBm' 13 10 ...
        '$n_g = $' num2str(input_params.ng_1_value_list(m_gate)) ', $\Phi_{\mathrm{ext}}$ = ' ...
        num2str(input_params.flux_1_value_list(m_flux)) '$\Phi_0$' 13 10 ...
        '$\Delta$ = ' num2str(raw_data_matrix.detuning_point(m_data_counter)) 'MHz, ' ...
        'Repetition number= ' num2str(m_repetition) 13 10 ... ...
        'lifetime 1 from RTS = ' num2str(round(temp.lifetime_state_1_final_iteration*1e6, 2)) '$\mu$s' ...
        'lifetime 2 from RTS = ' num2str(round(temp.lifetime_state_2_final_iteration*1e6, 2)) '$\mu$s' 13 10 ...
        'lifetime 1 from PSD fit = ' num2str(round(temp.lifetime_state_1_lorentz_fit*1e6, 2)) '$\mu$s' ...
        'lifetime 2 from PSD fit = ' num2str(round(temp.lifetime_state_2_lorentz_fit*1e6, 2)) '$\mu$s'], 'interpreter', 'latex')
    legend show

    if post_run_params.save_png_param == 1
        save_file_name = [post_run_params.rts_fig_directory num2str(m_power) '_' ...
            num2str(m_bias_point) '_' num2str(m_detuning) ...
            '_' num2str(m_repetition) ...
            '_' num2str(input_params.input_power_value_list(m_power)) 'dBm_' ...
            '_ng_' num2str(input_params.ng_1_value_list(m_gate)) '_flux_' ...
            num2str(input_params.flux_1_value_list(m_flux)*1000) 'm_detuning_' ...
            num2str(raw_data_matrix.detuning_point(m_data_counter)) 'MHz_RTS_PSD.png'];
        saveas(RTS_PSD_figure, save_file_name)
        if post_run_params.save_fig_file_param == 1
            save_file_name = [post_run_params.rts_fig_directory '/fig_files/' num2str(m_power) '_' ...
            num2str(m_bias_point) '_' num2str(m_detuning) ...
            '_' num2str(m_repetition) ...
            '_' num2str(input_params.input_power_value_list(m_power)) 'dBm_' ...
            '_ng_' num2str(input_params.ng_1_value_list(m_gate)) '_flux_' ...
            num2str(input_params.flux_1_value_list(m_flux)*1000) 'm_detuning_' ...
            num2str(raw_data_matrix.detuning_point(m_data_counter)) 'MHz_RTS_PSD.fig'];
            saveas(RTS_PSD_figure, save_file_name)
        end
    end

    clear RTS_PSD_figure ...
          save_file_name
end
%% Plot Poissonian
if temp.analysis.current_run_bistability_existence && plotting.Poisson_fig_plot_param 
    if plotting.plot_visible == 1 
        Poissonian_figure = figure('units', 'normalized', 'outerposition', [0 0 1 1]);
    elseif plotting.plot_visible == 0 
        Poissonian_figure = figure('units', 'normalized', 'outerposition', [0 0 1 1],'visible','off');
    end

    bar(temp.switch_time_bin_centers_1*1e6, log(temp.hist_count_1), 'r', 'FaceAlpha', 0.25, 'DisplayName', 'State 1 hist')
    hold on
    bar(temp.switch_time_bin_centers_2*1e6, log(temp.hist_count_2), 'b', 'FaceAlpha', 0.25, 'DisplayName', 'State 2 hist')
    plot(temp.switch_time_bin_centers_1*1e6, temp.poisson_theory_1, 'r', 'linewidth', 2, 'DisplayName', 'State 1 fit')
    plot(temp.switch_time_bin_centers_2*1e6, temp.poisson_theory_2, 'b', 'linewidth', 2, 'DisplayName', 'State 2 fit')
    xlabel('Switching time ($\mu$s)', 'interpreter', 'latex')
    ylabel('log(Count)', 'interpreter', 'latex')
    title(['Poisson fit for P$_{\mathrm{in}}$ = ' num2str(input_params.input_power_value_list(m_power)) 'dBm' 13 10 ...
        '$n_g = $' num2str(input_params.ng_1_value_list(m_gate)) ', $\Phi_{\mathrm{ext}}$ = ' num2str(input_params.flux_1_value_list(m_flux)) '$\Phi_0$' 13 10 ...
        '$\Delta$ = ' num2str(detuning_point) 'MHz' ], 'interpreter', 'latex')
    legend show
    annotation('textbox', [0.67, 0.33, 0.55, 0.3], 'String', ['Lifetime state 1 = ' 13 10 num2str(round(temp.poisson_lifetime_1_us, 2)) ...
        '$\pm$' num2str(round(temp.error_poisson_lifetime_1_us)) '$ \mu$s'], 'interpreter', 'latex', 'LineStyle', 'none', 'FontSize', 30, 'Color', 'r')
    annotation('textbox', [0.67, 0.23, 0.55, 0.3], 'String', ['Lifetime state 2 = ' 13 10 num2str(round(temp.poisson_lifetime_2_us, 2)) ...
        '$\pm$' num2str(round(temp.error_poisson_lifetime_1_us)) '$ \mu$s'], 'interpreter', 'latex', 'LineStyle', 'none', 'FontSize', 30, 'Color', 'b')
    annotation('textbox', [0.35, 0.45, 0.5, 0.3], 'String', ['Total counts = ' num2str(sum(temp.hist_count_1))], ...
        'interpreter', 'latex', 'LineStyle', 'none', 'FontSize', 30, 'Color', 'r')
    annotation('textbox', [0.35, 0.5, 0.5, 0.3], 'String', ['Total counts = ' num2str(sum(temp.hist_count_2))], ...
        'interpreter', 'latex', 'LineStyle', 'none', 'FontSize', 30, 'Color', 'b')

    if post_run_params.save_png_param == 1
            save_file_name = [post_run_params.fig_directory  num2str(m_power) '_' num2str(m_bias_point) '_' num2str(m_repetition)...
                '_ng_' num2str(input_params.ng_1_value_list(m_gate)) '_flux_' num2str(input_params.flux_1_value_list(m_flux)*1000) 'm_detuning_' num2str(detuning_point) 'MHz_poisson_fit.png'];
            saveas(Poissonian_figure, save_file_name)
            save_file_name = [post_run_params.fig_directory '/fig_files/' num2str(m_power) '_' num2str(m_bias_point) '_' num2str(m_repetition)...
                '_ng_' num2str(input_params.ng_1_value_list(m_gate)) '_flux_' num2str(input_params.flux_1_value_list(m_flux)*1000) 'm_detuning_' num2str(detuning_point) 'MHz_poisson_fit.fig'];
            saveas(Poissonian_figure, save_file_name)
    end
    clear Poissonian_figure ...
          save_file_name
end
input_params.analyzed_parameter(m_power, m_flux, m_gate, m_detuning, m_repetition) = 1;
clear moving_mean_average_time ...
      moving_mean_average_number ...
      raw_data ...
      m_power ...
      m_flux ...
      m_gate ...
      m_detuning ...
      m_repetition ...
      m_bias_point ...
      detuning_point ...
      temp
close all